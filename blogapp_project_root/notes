create a templates dir and then create a fir in templates dir with appname.

so each templates will be considered specific to that app.

so for each app we create a dir with same name in templates dir.


post = [
    {'author': 'jiss',
     'title': 'blogpost',
     'content': 'First Post',
     }
]


def home(request, template_name='blogapp/index.html'):
    context = {'post': post}
    return render(request, template_name, context)



here v pass the post data as a dict in view function.

by passing context dict as an argument to render() it allows the templates to
render the contents of context dictionary.


so the key name 'post' is accessible with in the template index.html
and we can loop thru it to print the data in the post to the template.


template engine in django allows to write code with in the template.


    <section id="content">
        <div class="container">
            {% for each in post %}
                <p>
                <strong>Author:</strong> <span>{{each.author}}</span>
                    </p>
                <p>
                <strong>Title:</strong> <span>{{each.title}}</span>
                </p>
                <p>
                <strong>Content:</strong> <span>{{each.content}}</span>
                </p>
            {% endfor %}
        </div>
    </section>


use  {{}} to access a variable inside the post.




template inheritamce


nehriting the base template to each other templates.



error
---------
django.db.utils.OperationalError: no such table: auth_user

problem is not created database for the project
so to create them,
- python manage.py migrate



in django orm we can represent db structures as classes.
and we call them as models.


each class will be a table in the db.
and each attribute of class will be a diff field in that table.

all models inherit from models.Model class.

TextField is alwaysu unrestricted field.  so need to specif the max lenght






from django.db import models
from datetime import datetime
# import the user model
from django.contrib.auth.models import User


# Create your models here.
class Post(models.Model):
    title = models.CharField(max_length=100)
    content = models.TextField()
    date = models.DateField(default=datetime.now)
    author = models.ForeignKey(User, on_delete=models.CASCADE)


author = models.ForeignKey(User, on_delete=models.CASCADE)

-- we want to tell django wat to do if author created the post gets deleted. 

so here models.CASCADE means delete the post as well when the user is deleted.

if a user has 10 post, and if user is deleted then the aforementioned posts also gets deleted.

but if v delete a post, it not delete the user who publshed it.


onve ceated a models need t run the migrations to uodate that changes in the db.

python manage.py makemigrations

 -- it makes an 0001_initial.py file i migrations.
	ehich conatins sqlcode to be executed.
to see the sqlcode,
 - python manage.py sqlmigrate bloagapp 0001_initial

to apply the migrayions finally to the db,
	- python manage.py migrate 
	it will create a table in the db.



by running migrations we cal always make change to the db when v made changes in the model.

Using Django shell
-----------------------


from appname.models import User

>>> User.objects.all()
<QuerySet [<User: jiss>, <User: modric>]>

> User.objects.first()
<User: jiss>


>> User.objects.filter(username='jiss')
<QuerySet [<User: jiss>]>



>>> user = User.objects.get(id=1)
>>> user


p>{{post.date|date:"F d, Y"}}</p> -- strips the time from the datetime,
refer : https://docs.djangoproject.com/en/2.2/ref/templates/builtins/#date





create a new app for users.
create  register form for them using userCreationForm class

from django.shortcuts import render
# import UserCreationForm
from django.contrib.auth.forms import UserCreationForm


# Create your views here.
def register(request, template_name='usersapp/register.html'):
    form = UserCreationForm()
    return render(request, template_name, {'form': form})


here v shud create the templates  in app dir.
-usersapp
	-templates
		-usersapp
			register.html




# Create your views here.
def register(request):
    # create instance of form , if request is not posted or if posted.
    if request.method == 'POST':
        form = RegisterForm(request.POST)
        if form.is_valid():
            form.save()
            username = form.cleaned_data.get('username')
            messages.success(request, f'Account created for {username}!')
            return redirect('blogapp-home')
    else:
        form = RegisterForm()
    return render(request, 'usersapp/register.html', {'form': form})


when v submitted the form it submitted as a post request,
and in view if request.method  is post.
v create a form instance with the posted data.
so now our form has usename, email, and passwords fields.
and then if our form is valid. then save it to db, if not valid return the register template with form having the value v submitted, and then fetch the username form that form,
later v print a flash message success bcose it is saved successfully,
later v redirect the page to our home page.


in case method is not post v create an empty form

	 

changing navbar link based on user authentcation
---------------------------------------------------

{% if user.is_authenticated %}
    <a class="nav-item nav-link" href="{% url 'usersapp:logout' %}">Logout</a>
{% else %}
<a class="nav-item nav-link" href="{% url 'usersapp:login' %}">Login</a>
<a class="nav-item nav-link" href="{% url 'usersapp:register' %}">Register</a>
{% endif %}


next giving restriction to access a user profile b4 login
----------------------------------------------------


checkin before accessing user profile page

# importing login requfred decorator before accesing profile page
from django.contrib.auth.decorators import login_required

#later add 
@login_required
def user_profile(request):
    return render(request, template_name='usersapp/profile.html')



page not fornd
-------------------
Request URL:	http://127.0.0.1:8080/accounts/login/?next=/user/profile/

given abv is the default path django looks for login,
so here v need to expicilty tell django to where to find our login route.
 
we can easily set that by adding LOGIN_URL in settings.py file

LOGIN_URL = 'userapp:login'

our url changes to: while moving to login/

http://127.0.0.1:8080/user/login/?next=/user/profile/
which means next after login we naviagte to profile page	


thus setting this allows users to login and then redirect to the profile page once loggedout
 


one to one relationship
----------------------
one user have one prfile and one profile associates with one user.


MODELS.PY
--------------

from django.db import models

from django.contrib.auth.models import User


# Create your models here.

class Profile(models.Model):
	v set a one to one relation with feafult User model in django
    user = models.OneToOneField(User, on_delete=models.CASCADE)
	if user is delted proile deleted bt if profile deleted user not 	deleted.
	   image = models.ImageField(default='default.jpg', upload_to='profile_images')

    def __str__(self):
        return f"{self.user.username}'s profile"


     


python manage.py shell
-----------------------
from django.contrib.auth.models import User
user = User.objects.filter('megan').first()

user.profile
user.profile.user
user.profile.image
user.profile.image.url


now v can access the profile from user models since onetooine relationship.



megan
testing888




